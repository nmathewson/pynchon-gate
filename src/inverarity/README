Inverarity is a distributor: a fast PIR server for the Pynchon Gate.


Its job is to hold a collection of fixed-size buckets (or a 'distribution'),
and serve requests to users.  When a user wants to download a bucket B, she
runs a client that generates N random-looking strings S_1...S_N such that the
xor of all of those strings has one bit set corresponding to the bucket B.
The client then connects to N *different* distributors over authenticated TLS
connections, and asks each one to answer a request corresponding to one
S_i value.  The distributor then computes a value equal to the xor of
every bucket corresponding to a 1 bit in S_i.  The user can then xor
these values together to get the value of the bucket.

If the user follows the protocols correctly and knows good public keys for
all the distributors, then nobody can know which bucket the user is
downloading, unless ALL of the instances collaborate to expose the user.


To build Inverarity, you will need:
  - A c99 compiler and a modern unixy host
  - OpenSSL 0.9.8 or later (please, make sure you're using one of the
    not-broken versions)
  - Libevent 2.0.x or later (2.0.13-stable or later is recommended).  You can
    get the latest version from libevent.org.
  - pkg-config.  If your pkg-config setup is broken, or it doesn't have
    libevent2 and openssl, you'll need to override some things; look at
    the makefile for more information.

To try Inverarity, you will need:
  - Some way to make one or more distribution files.  You might be able to
    hack testing/dummydist.py into something you can use.
  - A certificate and a key -- self-signed is fine.  It's okay for the key to
    be encrypted.
  - Some way to make requests.  You might be able to hack testing/dummyclient.py
    into something useful here.
  - PATIENCE.



Here's how to do it.

1. Install libevent and openssl if you haven't.

2. run make.  Let's hope it works.  You might need to twiddle some
   definitions in the Makefile.  There's no autogoop yet.

3. Make a directory structure.  This should all be owned by you, and
   mode 700 (readable,writable, and executable by owner, and by nobody
   else).

   The directory structure should contain two subdirectories: "keys" and
   "dist".

   "dist" should contain the files that you're going to have Inverarity
   distribute.  Each one needs to have a filename that ends with ".bsZZZ",
   where ZZZ is the block size.  So for example, a file that has 64 KiB
   blocks should be named something like "a_file.bs65536".  Blocks must be
   multiples of 64 bytes in length.

   "keys" will contain three files:

     dh_params : TLS diffie hellman parameters.  If you don't create this,
      Inverarity will spend a while building it at startup.  It will do this
      very slowly, so go make some soup or something while you wait if
      you've got a slow system.

     tls_cert : A PEM-encoded X509 certificate.  You need to generate this
     yourself.  It can be self-signed.  It must correspond to the secret key:

     tls_secret_key : A secret key for tls_cert, in PEM form.  You need
     to generate this yourself.  It can be encrypted.

     You can generate tls_secret_key and tls_cert using openssl as follows:

       openssl genrsa -aes256 -out tls_secret_key
       openssl req -new -key tls_secret_key -out distributor.csr
       openssl x509 -req -days 365 -in distributor.csr -signkey tls_secret_key -out tls_cert

4. Start inverarity.  The syntax is:

      ./inverarity DIR ADDRESS PORT

   Where DIR is the top of the directory structure you made above, and
   ADDRESS:PORT is the address to bind.

   ADDRESS and PORT are optional; they default to "localhost" and "49494".

5. Fetch stuff from inverarity.  The protocol as implemented so far is
   specified in "spec.txt" in this directory.

   There's a ***DUMMY*** Python client in "testing/dummyclient.py".  You
   would want to hack it a lot before you actually used it for anything but
   amusement.  It is hardwired:

       - To connect to the same server (127.0.0.1:4949) a few times in
         sequence.
       - To only download stuff for one distribution (generated by
         "testing/dummydist.py"
       - To only work for a distribution containing 49 blocks of 64 bytes.
       - To always fetch the 12th blcok.

5.1. Simulate maintenance.  You can change the contents of the dist
   directory, and sighup

6. Start hacking!  There's a lot more to do; have a gander at the TODO file
   in this directory, look around the code, etc.  The functions-level
   documentation is in the header files.


Implementation notes
====================


To take advantage of locality, Inverarity handles many client requests in
parallel.  It does this by iterating over the blocks, xoring each one into a
response field of each pending request (or not, depending on the request) as
it goes along the iteration.  This avoid having to jump around the blocks
in the distribution in a nonlinear way.


We didn't realize it when we were speccing Pynchon Gate (or if we did, I'd
forgotten it), but it's critical that some of these operations be
constant-time.  In particular, we don't want to do something like:
{
    foreach (block B)
      foreach (pending request R)
        if (the bit for B is set in R) // whoops!
           R.response = R.response xor B
}
In the worst case, an attacker who controlled every request except for a
single target request could use the data-dependent branch above to mount a
timing attack to learn how many bits were set in the target, and possibly to
learn some of the bits set in the target.  Not good!  Instead, we do some
timing-invariance trickery.


Currently, Inverarity has one thread per distribution it knows about, plus
one in which the TLS+libevent IO code runs.  This is probably suboptimal:
instead, it should probably have one thread per CPU for distribution
requests, plus one thread per CPU for TLS+IO.


To keep our sanity, we try to minimize communication between threads.  We
pass requests to worker threads and back to the IO thread via simple queues,
notifying the worker threads with pthreads conditions, and notifying the IO
thread via Libevent.  Almost nothing is shared between threads, so almost
nothing needs to be locked.


Inverarity loads its distribution files with mmap(); that might be a bad
idea in some cases, and it is SURE to be a bad idea on 32-bit architectures
with huge files.  If that ever matters, we should try a simple
seek()/read()-based thing.


The original pynchon spec suggests an algorithm where we iterate over the
buckets in a circular fashion, so that we can start processing new requests
at any point, and answer them whenever we reach the same point in the circle
again.  In this code, we always start answering a batch of requests at the
start of the distribution.

